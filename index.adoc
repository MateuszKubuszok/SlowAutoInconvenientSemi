// 35 minutes
:revealjs_totalTime: 2100
:revealjs_theme: serif
:revealjs_help: true

= Slow-Auto, Inconvenient-Semi

**escaping false dichotomy with sanely-automatic derivation**

---

Mateusz Kubuszok

== About me

[%step]
* breaking things in Scala for 9 years
* a little bit of open source - including co-authoring Chimney for almost 7 years now
* blog at https://kubuszok.com[Kubuszok.com]
* niche https://leanpub.com/jvm-scala-book[Things you need to know about JVM (that matter in Scala)] ebook

[NOTE.speaker]
--
--

== Agenda

[%step]
* what is type class
* what is type class derivation
* automatic and semi-automatic derivation a'la Circe
* semi-automatic derivation a'la Jsoniter
* sanely-automatic derivation a'la Chimney
* does it matter to library users how these approach differ

=== Examples

image::img/qr-code.png[Link to examples,40%,40%]

https://github.com/MateuszKubuszok/derivation-benchmarks

[NOTE.speaker]
--
We cannot afford to have a study each example in deep, since it could take a whole day, so as a homework or an excercise for the reader here's the link.
--

== Type class

[%step]
* interface
* with type paremeters
* whose implementation can be automatically provided based on their type only

=== !

[source, scala]
--
trait Encoder[A] {
  def apply(a: A): Json // <-- JSON as data
}
object Encoder {
  given encodeString: Encoder[String] = ...
  given encodeInt: Encoder[Int] = ...
  given encodeDouble: Encoder[Double] = ...
}
--

[%step]
[source, scala]
--
extension [A](value: A) {
  def asJson(using encoder: Encoder[A]): Json = encoder(value)
}
--

[%step]
[source, scala]
--
"value".asJson // using Encoder.encodeString
1024.asJson // using Encoder.encodeInt
3.13.asJson // using Encoder.encodeDouble
--

=== !

What if nobody wrote the implementation explicitly for my type?

[%step]
[source, scala]
--
case class Address(value: String)
case class User(name: String, address: Address)
--

[%step]
[source, scala]
--
Address("Paper St. 19").asJson // ???
User("John Smith", Address("Paper St. 19")).asJson // ???
--

[%step]
[source]
--
No given instance of type Encoder[Address] was found for parameter encoder of
method asJson in object ...
No given instance of type Encoder[User] was found for parameter encoder of
method asJson in object ...
--

== Type class derivation

image::img/derivation.png[Derivation,100%,100%]

[NOTE.speaker]
--
* for some types implementations are some build-in
* someone provided a way of combining implementations for each field
  into an implementation for a whole `case class`
* someone provided a way of combining implementations for each subtype
  into an implementation for a whole `sealed` type
* someone is usually the library's author
--

=== Derivation a'la Circe

=== !

[source, scala]
--
trait Encoder[A] {
  def apply(a: A): Json // <-- JSON as data
}
--

[%step]
[source, scala]
--
extension [A](value: A) {
  def asJson(using encoder: Encoder[A]): Json = encoder(value)
}
--

[%step]
[source, scala]
--
case class Address(value: String)
case class User(name: String, address: Address)
--

[%step]
[source, scala]
--
import MagicImportOfSomethingThatCreatesEncoders.given

Address("Paper St. 19").asJson // generates Encoder[Address] on demand
User("John Smith", Address("Paper St. 19")).asJson // ditto but for User
--

[%step]
[source, scala]
--
import ImportOfSomethingThatLetsYouCreateEncoders.deriveEncoder

given addressEncoder: Encoder[Address] = deriveEncoder[Address]
given userEncoder: Encoder[User] = deriveEncoder[User]

Address("Paper St. 19").asJson // using addressEncoder
User("John Smith", Address("Paper St. 19")).asJson // using userEncoder
--

[NOTE.speaker]
--
* reminder what API we have
* automatic derivation - sometimes it's always on by default
* automatic derivation has to work as a fallback to existing values
* semiautomatic derivation - sometimes it's defined in the compatnion object
* semiautomatic derivation must create a new value without looking for it in implicit scope, or NullPointerException/InitializationError/StackOverflowException
--

[.small-h2]
=== Automatic derivation of Address

[source, scala]
--
implicitly[Encoder[Address]] // <-- using Encoder[Address]
--

image::img/automatic-derivation-of-Address.png[Automatic Derivation of Address,100%,100%]

[NOTE.speaker]
--
For simplicity we're ignoring the sealed scenario
--

[.small-h2]
=== Semi-automatic derivation of Address

[source, scala]
--
deriveEncoder[Address] // <-- creates new Encoder[Address]
--

image::img/semi-automatic-derivation-of-Address.png[Semi-automatic Derivation of Address,100%,100%]

[NOTE.speaker]
--
For simplicity we're ignoring the sealed scenario
--

[.small-h2]
=== Automatic derivation of User

[source, scala]
--
implicitly[Encoder[User]] // <-- using Encoder[User]
--

image::img/automatic-derivation-of-User.png[Automatic Derivation of User,100%,100%]

[NOTE.speaker]
--
For simplicity we're ignoring the sealed scenario
--

[.small-h2]
=== Semi-automatic derivation of User

[source, scala]
--
implicitly[Encoder[User]] // <-- creates new Encoder[User]
--

image::img/semi-automatic-derivation-of-User.png[Semi-automatic Derivation of User,100%,100%]

[NOTE.speaker]
--
For simplicity we're ignoring the sealed scenario
--

TODO: add example with lists of 

== OK, but where is the code?

Wouldn't it be easier to understand with some examples?

=== 1. We are focusing on user-side of the derivation story

=== 2. Code is in the link

image::img/qr-code.png[Link to examples,40%,40%]

https://github.com/MateuszKubuszok/derivation-benchmarks

[.small-h2]
=== 3. If you really need the derivation-internals-explanation-experience

[%step]
image::img/3-hours-later.jpg[3h later,80%,80%]

[NOTE.speaker]
--
...imagine it's 3h later, you saw a lot of code examples and you understand at best as much as you do now.
--

== Why people bother with semi-automatic derivation?

=== 1. They want to make sure that they use the same implementation everywhere

[NOTE.speaker]
--
We're not going to question that use case.
--

=== 2. Speed

=== !

[source, scala]
--
// We're use Circe:
// trait Encoder[A] { ... } turns A -> Json
// trait Decoder[A] { ... } turns Json -> Either[Decoder.DecodingError, A]

case class Out(...) // <-- really big case class with nested case classes

// value -> Json -> value again
def roundTrip(out: Out): (Json, Either[Decoder.DecodingError, Out]) = {
  val json = out.asJson // <-- encode as Json using Encoder[Out]
  val parsed = json.as[Out] // <-- decode from Json using  Decoder[Out]
  json -> parsed
}
--

This shouldn't be hard?

[NOTE.speaker]
--
We're going to use Circe.

Common knowledge says autoderivation is very slow, and when your build times grow, use semi-automatic derivation, automatic derivation cosidered harmful, etc.
--

=== !

image::img/json-compilation-times-1.png[Json Compilation Times,80%,80%]

[.small]
(less is better)

[NOTE.speaker]
--
Probably the common knowledge about auto vs semi is outdated on Scala 2.13.

[source]
----
                     Scala 2   Scala 3  Units
compilation of      cold hot  cold hot
circeGenericAuto      14   4    46  16      s
circeGenericSemi      12   3    10   1      s
circeMagnoliaAuto     13   2    65  32      s
circeMagnoliaSemi     12   7    12   2      s
jsoniterScalaSanely    -   -     9   1      s
jsoniterScalaSemi     10   4     8   1      s
----
--

=== !

Scala 2.13.14

[source,scala]
--
[info] Benchmark                          Mode  Cnt   Score   Error   Units
[info] JsonRoundTrips.circeGenericAuto    thrpt  10   7.319 ± 0.011  ops/ms
[info] JsonRoundTrips.circeGenericSemi    thrpt  10   6.775 ± 0.013  ops/ms
--

Scala 3.3.3

[source,scala]
--
[info] Benchmark                            Mode  Cnt   Score   Error   Units
[info] JsonRoundTrips.circeGenericAuto     thrpt   10   0.490 ± 0.432  ops/ms
[info] JsonRoundTrips.circeGenericSemi     thrpt   10   4.607 ± 0.014  ops/ms
--

[.small]
(more is better)

[.small-h2]
=== Auto vs Semi on Scala 2

[.small]
[%step]
* PR #5649 - _Faster compilation of inductive implicits_ (closed)
* PR #6481 - _Topic/inductive implicits 2.13.x_ (closed)
* PR #6580 - _Prune polymorphic implicits more aggressively_ (merged)
* PR #7012 - _Speed up implicit resolution by avoiding allocations when traversing TypeRefs in core_ (merged)
* and more

[%step]
[source, scala]
--
             1) baseline - scalac 2.13.x  2) scalac 2.13.x with matchesPtInst
 HList Size
  50          4                            3
 100          7                            3
 150         15                            4
 200         28                            4
 250         48                            5
 300         81                            6
 350        126                            8
 400        189                           11
 450        322                           13
 500        405                           16         Compile time in seconds
--

[NOTE.speaker]
--
There was a series of Miles Sabin PRs improving performance of implicit resolution - 2 first PRs got closed but the third on got finally merged in 2.13-M5.

Some of that work was ported to Scala 3 but perhaps not everything yet.
--

=== !

Could something else improve performance?

== Magnolia

[%step]
* alternative to Shapeless/Mirrors
* boasts about:

   - better API
   - better performance
   - better compilation times
   - better error messages when derivation fail

=== Error messages

TODO semi w shapeless

TODO semi w magnolii

TODO auto

[NOTE.speaker]
--
We implemented out own simplified Circe-Magnolia on Scala 2 and 3.
--

=== !

image::img/json-compilation-times-2.png[Json Compilation Times,80%,80%]

[.small]
(less is better)

[NOTE.speaker]
--
Probably the common knowledge about Magnolia's compile times on Scala 2 is outdated on Scala 3.

[source]
----
                     Scala 2   Scala 3  Units
compilation of      cold hot  cold hot
circeGenericAuto      14   4    46  16      s
circeGenericSemi      12   3    10   1      s
circeMagnoliaAuto     13   2    65  32      s
circeMagnoliaSemi     12   7    12   2      s
jsoniterScalaSanely    -   -     9   1      s
jsoniterScalaSemi     10   4     8   1      s
----
--

=== !

Scala 2.13.14

[source,scala]
--
[info] Benchmark                          Mode  Cnt   Score   Error   Units
[info] JsonRoundTrips.circeGenericAuto    thrpt  10   7.319 ± 0.011  ops/ms
[info] JsonRoundTrips.circeGenericSemi    thrpt  10   6.775 ± 0.013  ops/ms
[info] JsonRoundTrips.circeMagnoliaAuto   thrpt  10   7.689 ± 0.013  ops/ms
[info] JsonRoundTrips.circeMagnoliaSemi   thrpt  10   7.838 ± 0.013  ops/ms
--

Scala 3.3.3

[source,scala]
--
[info] Benchmark                            Mode  Cnt   Score   Error   Units
[info] JsonRoundTrips.circeGenericAuto     thrpt   10   0.490 ± 0.432  ops/ms
[info] JsonRoundTrips.circeGenericSemi     thrpt   10   4.607 ± 0.014  ops/ms
[info] JsonRoundTrips.circeMagnoliaAuto    thrpt   10   0.077 ± 0.039  ops/ms
[info] JsonRoundTrips.circeMagnoliaSemi    thrpt   10   5.590 ± 0.013  ops/ms
--

[.small]
(more is better)

[NOTE.speaker]
--
Magnolia on Scala 3 was implemented on top of Mirrors.
--

=== !

Shapeless/Mirrors/Magnolia - different APIs, same approach.

Did anyone tries something else?

== Jsoniter Scala

[%step]
* prioritizes performance
* no automatic derivation
* no need to derive intermediate instances

[%step]
How?

=== !

TODO: code example

[.small-h2]
=== Recursive semi-automatic derivation

image::img/recursive-macro-derivation.png[Recursive Macro Derivation]

[.small-h2.columns]
=== Recursive semi-automatic derivation

[.column]
--
image::img/derivation.png[Derivation]

[.small]
* delegates everything to implicit search
* types supported OOTB are handled via implicits in companion object
--

[.column]
--
image::img/recursive-macro-derivation.png[Recursive Macro Derivation]

[.small]
* use implicit search only for overrides
* types supported OOTB are handled by macro, implicit scope is empty by default
--

=== !

OK, but what does this gibberish mean for users?

=== !

image::img/json-compilation-times-3.png[Json Compilation Times,80%,80%]

[.small]
(less is better)

[NOTE.speaker]
--

[source]
----
                     Scala 2   Scala 3  Units
compilation of      cold hot  cold hot
circeGenericAuto      14   4    46  16      s
circeGenericSemi      12   3    10   1      s
circeMagnoliaAuto     13   2    65  32      s
circeMagnoliaSemi     12   7    12   2      s
jsoniterScalaSanely    -   -     9   1      s
jsoniterScalaSemi     10   4     8   1      s
----
--

=== !

Scala 2.13.14

[source,scala]
--
[info] Benchmark                          Mode  Cnt   Score   Error   Units
[info] JsonRoundTrips.circeGenericAuto    thrpt  10   7.319 ± 0.011  ops/ms
[info] JsonRoundTrips.circeGenericSemi    thrpt  10   6.775 ± 0.013  ops/ms
[info] JsonRoundTrips.circeMagnoliaAuto   thrpt  10   7.689 ± 0.013  ops/ms
[info] JsonRoundTrips.circeMagnoliaSemi   thrpt  10   7.838 ± 0.013  ops/ms
[info] JsonRoundTrips.jsoniterScalaSemi   thrpt  10  20.081 ± 0.151  ops/ms
--

Scala 3.3.3

[source,scala]
--
[info] Benchmark                            Mode  Cnt   Score   Error   Units
[info] JsonRoundTrips.circeGenericAuto     thrpt   10   0.490 ± 0.432  ops/ms
[info] JsonRoundTrips.circeGenericSemi     thrpt   10   4.607 ± 0.014  ops/ms
[info] JsonRoundTrips.circeMagnoliaAuto    thrpt   10   0.077 ± 0.039  ops/ms
[info] JsonRoundTrips.circeMagnoliaSemi    thrpt   10   5.590 ± 0.013  ops/ms
[info] JsonRoundTrips.jsoniterScalaSemi    thrpt   10  21.480 ± 0.070  ops/ms
--

[.small]
(more is better)

[NOTE.speaker]
--
I have to admit: I am cheating, Jsoniter parses and writes to String while, Circe parses and writes to Json AST.
--

=== !

But can it be automatic?

== Automatic derivation a'la Chimney

TODO

== Summary

== Thank you!

image::img/qr-code.png[Link to examples,40%,40%]

https://github.com/MateuszKubuszok/derivation-benchmarks

