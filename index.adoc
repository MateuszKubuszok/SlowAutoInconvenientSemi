// 35 minutes
:revealjs_totalTime: 2100
:revealjs_theme: serif
:revealjs_help: true

= Slow-Auto, Inconvenient-Semi

**escaping false dichotomy with sanely-automatic derivation**

---

Mateusz Kubuszok

== About me

[%step]
* breaking things in Scala for 9 years
* a little bit of open source - including co-authoring Chimney for almost 7 years now
* blog at https://kubuszok.com[Kubuszok.com]
* niche https://leanpub.com/jvm-scala-book[Things you need to know about JVM (that matter in Scala)] ebook

[NOTE.speaker]
--
--

== Agenda

[%step]
* what is type class
* what is type class derivation
* automatic and semi-automatic derivation a'la Circe
* semi-automatic derivation a'la Jsoniter
* sanely-automatic derivation a'la Chimney
* does it matter to library users how these approach differ

=== Examples

image::img/qr-code.png[Link to examples,40%,40%]

https://github.com/MateuszKubuszok/derivation-benchmarks

[NOTE.speaker]
--
We cannot afford to have a study each example in deep, since it could take a whole day, so as a homework or an excercise for the reader here's the link.
--

== Type class

[%step]
* interface
* with type paremeters
* whose implementation can be automatically provided based on their type only

=== !

[source, scala]
--
trait Encoder[A] {
  def apply(a: A): Json // <-- JSON as data
}
object Encoder {
  given encodeString: Encoder[String] = ...
  given encodeInt: Encoder[Int] = ...
  given encodeDouble: Encoder[Double] = ...
}
--

[%step]
[source, scala]
--
extension [A](value: A) {
  def asJson(using encoder: Encoder[A]): Json = encoder(value)
}
--

[%step]
[source, scala]
--
"value".asJson // using Encoder.encodeString
1024.asJson // using Encoder.encodeInt
3.13.asJson // using Encoder.encodeDouble
--

=== !

What if nobody wrote the implementation explicitly for my type?

[%step]
[source, scala]
--
case class Address(value: String)
case class User(name: String, address: Address)
--

[%step]
[source, scala]
--
Address("Paper St. 19").asJson // ???
User("John Smith", Address("Paper St. 19")).asJson // ???
--

[%step]
[source]
--
No given instance of type Encoder[Address] was found for parameter encoder of
method asJson in object ...
No given instance of type Encoder[User] was found for parameter encoder of
method asJson in object ...
--

== Type class derivation

image::img/derivation.png[Derivation,100%,100%]

[.small]
(If you don't understand this diagram, you probably haven't spend 600h on a topic that most sane people avoid. The main reason we have these images is because people like colorful images on slides.)

[NOTE.speaker]
--
* for some types implementations are some build-in
* someone provided a way of combining implementations for each field
  into an implementation for a whole `case class`
* someone provided a way of combining implementations for each subtype
  into an implementation for a whole `sealed` type
* someone is usually the library's author
--

=== Derivation a'la Circe

=== !

[source, scala]
--
trait Encoder[A] {
  def apply(a: A): Json // <-- JSON as data
}
--

[%step]
[source, scala]
--
extension [A](value: A) {
  def asJson(using encoder: Encoder[A]): Json = encoder(value)
}
--

[%step]
[source, scala]
--
case class Address(value: String)
case class User(name: String, address: Address)
--

[%step]
[source, scala]
--
import MagicImportOfSomethingThatCreatesEncoders.given

Address("Paper St. 19").asJson // generates Encoder[Address] on demand
User("John Smith", Address("Paper St. 19")).asJson // ditto but for User
--

[%step]
[source, scala]
--
import ImportOfSomethingThatLetsYouCreateEncoders.deriveEncoder

given addressEncoder: Encoder[Address] = deriveEncoder[Address]
given userEncoder: Encoder[User] = deriveEncoder[User]

Address("Paper St. 19").asJson // using addressEncoder
User("John Smith", Address("Paper St. 19")).asJson // using userEncoder
--

[NOTE.speaker]
--
* reminder what API we have
* automatic derivation - sometimes it's always on by default
* automatic derivation has to work as a fallback to existing values
* semiautomatic derivation - sometimes it's defined in the compatnion object
* semiautomatic derivation must create a new value without looking for it in implicit scope, or NullPointerException/InitializationError/StackOverflowException
--

[.small-h2]
=== Automatic derivation of Address

[source, scala]
--
implicitly[Encoder[Address]] // <-- using Encoder[Address]
--

image::img/automatic-derivation-of-Address.png[Automatic Derivation of Address,100%,100%]

[NOTE.speaker]
--
For simplicity we're ignoring the sealed scenario
--

[.small-h2]
=== Semi-automatic derivation of Address

[source, scala]
--
deriveEncoder[Address] // <-- creates new Encoder[Address]
--

image::img/semi-automatic-derivation-of-Address.png[Semi-automatic Derivation of Address,100%,100%]

[NOTE.speaker]
--
For simplicity we're ignoring the sealed scenario
--

[.small-h2]
=== Automatic derivation of User

[source, scala]
--
implicitly[Encoder[User]] // <-- using Encoder[User]
--

image::img/automatic-derivation-of-User.png[Automatic Derivation of User,100%,100%]

[NOTE.speaker]
--
For simplicity we're ignoring the sealed scenario
--

[.small-h2]
=== Semi-automatic derivation of User

[source, scala]
--
implicitly[Encoder[User]] // <-- creates new Encoder[User]
--

image::img/semi-automatic-derivation-of-User.png[Semi-automatic Derivation of User,100%,100%]

[NOTE.speaker]
--
For simplicity we're ignoring the sealed scenario
--

TODO: add example with lists of 

== OK, but where is the code?

Wouldn't it be easier to understand with some examples?

=== 1. We are focusing on user-side of the derivation story

=== 2. Code is in the link

image::img/qr-code.png[Link to examples,40%,40%]

https://github.com/MateuszKubuszok/derivation-benchmarks

[.small-h2]
=== 3. If you really need the derivation-internals-explanation-experience

[%step]
image::img/3-hours-later.jpg[3h later,80%,80%]

[NOTE.speaker]
--
...imagine it's 3h later, you saw a lot of code examples and you understand at best as much as you do now.
--

== Why people bother with semi-automatic derivation?

=== 1. They want to make sure that they use the same implementation everywhere

[NOTE.speaker]
--
We're not going to question that use case.
--

=== 2. "Speed"

=== !

[source, scala]
--
// We're use Circe:
// trait Encoder[A] { ... } turns A -> Json
// trait Decoder[A] { ... } turns Json -> Either[Decoder.DecodingError, A]

case class Out(...) // <-- really big case class with nested case classes

// value -> Json -> value again
def roundTrip(out: Out): (Json, Either[Decoder.DecodingError, Out]) = {
  val json = out.asJson // <-- encode as Json using Encoder[Out]
  val parsed = json.as[Out] // <-- decode from Json using  Decoder[Out]
  json -> parsed
}
--

This shouldn't be hard?

[NOTE.speaker]
--
We're going to use Circe.

Common knowledge says autoderivation is very slow, and when your build times grow, use semi-automatic derivation, automatic derivation cosidered harmful, etc.
--

=== !

image::img/json-compilation-times-1.png[Json Compilation Times,80%,80%]

[.small]
(less is better)

[NOTE.speaker]
--
Probably the common knowledge about auto vs semi is outdated on Scala 2.13.

[source]
----
                     Scala 2   Scala 3  Units
compilation of      cold hot  cold hot
circeGenericAuto      14   4    46  16      s
circeGenericSemi      12   3    10   1      s
circeMagnoliaAuto     13   2    65  32      s
circeMagnoliaSemi     12   7    12   2      s
jsoniterScalaSanely    -   -     9   1      s
jsoniterScalaSemi     10   4     8   1      s
----
--

=== !

Scala 2.13.14

[source,scala]
--
[info] Benchmark                          Mode  Cnt   Score   Error   Units
[info] JsonRoundTrips.circeGenericAuto    thrpt  10   7.319 ± 0.011  ops/ms
[info] JsonRoundTrips.circeGenericSemi    thrpt  10   6.775 ± 0.013  ops/ms
--

Scala 3.3.3

[source,scala]
--
[info] Benchmark                            Mode  Cnt   Score   Error   Units
[info] JsonRoundTrips.circeGenericAuto     thrpt   10   0.490 ± 0.432  ops/ms
[info] JsonRoundTrips.circeGenericSemi     thrpt   10   4.607 ± 0.014  ops/ms
--

[.small]
(more is better)

[.small-h2]
=== Auto vs Semi on Scala 2

[.small]
[%step]
* PR #5649 - _Faster compilation of inductive implicits_ (closed)
* PR #6481 - _Topic/inductive implicits 2.13.x_ (closed)
* PR #6580 - _Prune polymorphic implicits more aggressively_ (merged)
* PR #7012 - _Speed up implicit resolution by avoiding allocations when traversing TypeRefs in core_ (merged)
* and more

[%step]
[source, scala]
--
             1) baseline - scalac 2.13.x  2) scalac 2.13.x with matchesPtInst
 HList Size
  50          4                            3
 100          7                            3
 150         15                            4
 200         28                            4
 250         48                            5
 300         81                            6
 350        126                            8
 400        189                           11
 450        322                           13
 500        405                           16         Compile time in seconds
--

[NOTE.speaker]
--
There was a series of Miles Sabin PRs improving performance of implicit resolution - 2 first PRs got closed but the third on got finally merged in 2.13-M5.

Some of that work was ported to Scala 3 but perhaps not everything yet.
--

=== !

Could something else improve performance?

== Magnolia

[%step]
* alternative to Shapeless/Mirrors
* boasts about:

   - better API
   - better performance
   - better compilation times
   - better error messages when derivation fail

[.small]
=== Error messages

Semi-automatic derivation

[source,scala]
--
case class Street(name: Either[String, Nothing]) // <-- should not be able to derive name
case class Address(street: Street)
case class User(name: String, address: Address)
--

[source,scala]
--
implicit val streetEncoder: Encoder[Street] = deriveEncoder
implicit val addressEncoder: Encoder[Address] = deriveEncoder
implicit val userEncoder: Encoder[User] = deriveEncoder

user.asJson
--

Shapeless' errors

[source,scala]
--
could not find Lazy implicit value of type DerivedAsObjectEncoder[Street]
   implicit val streetEncoder: Encoder[Street] = deriveEncoder
                                                 ^
--

Mirrors' errors

[source,scala]
--
  implicit val streetEncoder: Encoder[Street] = deriveEncoder
                                                ^^^^^^^^^^^^^
Failed to find an instance of Encoder[Either[String, Nothing]]
--

Magnolia's errors

[source,scala]
--
magnolia: could not find Encoder.Typeclass for type Either[String,Nothing]
     in parameter 'name' of product type Street
   implicit val streetEncoder: Encoder[Street] = EncoderSemi.derived
                                                             ^
--

[NOTE.speaker]
--
We implemented out own simplified Circe-Magnolia on Scala 2 and 3.
--

=== !

Automatic derivation

[source,scala]
--
case class Street(name: Either[String, Nothing])
case class Address(street: Street)
case class User(name: String, address: Address)

def roundTrip(user: User): (Json, Result[User]) = {
  val json = user.asJson
  val parsed = json.as[User]
  json -> parsed
}
--

Shapeless/Mirrors/Magnolia

[source,scala]
--
could not find implicit value for parameter encoder: Encoder[User]
     val json = user.asJson
                     ^
--

=== !

image::img/json-compilation-times-2.png[Json Compilation Times,80%,80%]

[.small]
(less is better)

[NOTE.speaker]
--
Probably the common knowledge about Magnolia's compile times on Scala 2 is outdated on Scala 3.

[source]
----
                     Scala 2   Scala 3  Units
compilation of      cold hot  cold hot
circeGenericAuto      14   4    46  16      s
circeGenericSemi      12   3    10   1      s
circeMagnoliaAuto     13   2    65  32      s
circeMagnoliaSemi     12   7    12   2      s
jsoniterScalaSanely    -   -     9   1      s
jsoniterScalaSemi     10   4     8   1      s
----
--

=== !

Scala 2.13.14

[source,scala]
--
[info] Benchmark                          Mode  Cnt   Score   Error   Units
[info] JsonRoundTrips.circeGenericAuto    thrpt  10   7.319 ± 0.011  ops/ms
[info] JsonRoundTrips.circeGenericSemi    thrpt  10   6.775 ± 0.013  ops/ms
[info] JsonRoundTrips.circeMagnoliaAuto   thrpt  10   7.689 ± 0.013  ops/ms
[info] JsonRoundTrips.circeMagnoliaSemi   thrpt  10   7.838 ± 0.013  ops/ms
--

Scala 3.3.3

[source,scala]
--
[info] Benchmark                            Mode  Cnt   Score   Error   Units
[info] JsonRoundTrips.circeGenericAuto     thrpt   10   0.490 ± 0.432  ops/ms
[info] JsonRoundTrips.circeGenericSemi     thrpt   10   4.607 ± 0.014  ops/ms
[info] JsonRoundTrips.circeMagnoliaAuto    thrpt   10   0.077 ± 0.039  ops/ms
[info] JsonRoundTrips.circeMagnoliaSemi    thrpt   10   5.590 ± 0.013  ops/ms
--

[.small]
(more is better)

[NOTE.speaker]
--
Magnolia on Scala 3 was implemented on top of Mirrors.
--

=== !

Shapeless/Mirrors/Magnolia - different APIs, same approach.

Did anyone tries something else?

== Jsoniter Scala

[%step]
* prioritizes performance
* no automatic derivation
* no need to derive intermediate instances

[%step]
How?

=== !

TODO: code example

[.small-h2]
=== Recursive semi-automatic derivation

image::img/recursive-macro-derivation.png[Recursive Macro Derivation]

[.small-h2.columns]
=== Recursive semi-automatic derivation

[.column]
--
image::img/derivation.png[Derivation]

[.small]
* delegates everything to implicit search
* types supported OOTB are handled via implicits in companion object
--

[.column]
--
image::img/recursive-macro-derivation.png[Recursive Macro Derivation]

[.small]
* use implicit search only for overrides
* types supported OOTB are handled by macro, implicit scope is empty by default
--

=== !

OK, but what does this gibberish mean for users?

=== !

image::img/json-compilation-times-3.png[Json Compilation Times,80%,80%]

[.small]
(less is better)

[NOTE.speaker]
--

[source]
----
                     Scala 2   Scala 3  Units
compilation of      cold hot  cold hot
circeGenericAuto      14   4    46  16      s
circeGenericSemi      12   3    10   1      s
circeMagnoliaAuto     13   2    65  32      s
circeMagnoliaSemi     12   7    12   2      s
jsoniterScalaSanely    -   -     9   1      s
jsoniterScalaSemi     10   4     8   1      s
----
--

=== !

Scala 2.13.14

[source,scala]
--
[info] Benchmark                          Mode  Cnt   Score   Error   Units
[info] JsonRoundTrips.circeGenericAuto    thrpt  10   7.319 ± 0.011  ops/ms
[info] JsonRoundTrips.circeGenericSemi    thrpt  10   6.775 ± 0.013  ops/ms
[info] JsonRoundTrips.circeMagnoliaAuto   thrpt  10   7.689 ± 0.013  ops/ms
[info] JsonRoundTrips.circeMagnoliaSemi   thrpt  10   7.838 ± 0.013  ops/ms
[info] JsonRoundTrips.jsoniterScalaSemi   thrpt  10  20.081 ± 0.151  ops/ms
--

Scala 3.3.3

[source,scala]
--
[info] Benchmark                            Mode  Cnt   Score   Error   Units
[info] JsonRoundTrips.circeGenericAuto     thrpt   10   0.490 ± 0.432  ops/ms
[info] JsonRoundTrips.circeGenericSemi     thrpt   10   4.607 ± 0.014  ops/ms
[info] JsonRoundTrips.circeMagnoliaAuto    thrpt   10   0.077 ± 0.039  ops/ms
[info] JsonRoundTrips.circeMagnoliaSemi    thrpt   10   5.590 ± 0.013  ops/ms
[info] JsonRoundTrips.jsoniterScalaSemi    thrpt   10  21.480 ± 0.070  ops/ms
--

[.small]
(more is better)

[NOTE.speaker]
--
I have to admit: I am cheating, Jsoniter parses and writes to String while, Circe parses and writes to Json AST.
--

=== !

But can it be automatic?

[.small]
== Automatic derivation a'la Chimney

Similar problem:

* derivation should be recursive
* macro should only use implicits for overrides

But:

* automatic derivation should be available without breaking the 2 above

[.small-h2]
=== Solution

[%step]
[source,scala]
--
trait TypeClass[A] extends TypeClass.AutoDerived[A] { ... }
object TypeClass {

  // semi-automatic derivation of TypeClass[A]
  inline def derived[A]: TypeClass[A] = ${ derivedImpl[A] }

  trait AutoDerived[A] { ... }
  object AutoDerived extends AutoDerivedLowPriorityImplicits
  trait AutoDerivedLowPriorityImplicits {

    // automatic derivation of TypeClass.AutoDerived[A]
    inline given derived[A]: AutoDerived[A] = ${ derivedImpl[A] }
  }
}
--

[%step]
[source,scala]
--
extension [A](value: A)
  // uses TypeClass[A] defined by user manually or with TypeClass.derived,
  // falling back on automatic derivation
  def method(using TypeClass.AutoDerived[A]) = ...
--

[%step]
[source,scala]
--
// allowed to try summoning TypeClass[Sth].
// NOT allowed to try summoning TypeClass.AutoDerived[Sth]!
def derivedImpl[A: Type]: Expr[TypeClass[A]] = ...
--

[%step]
[.small]
(Disclaimer: understanding this code is *not* necessary to understand its implications on the next slides)

=== !

Can we test it outside Chimney?

[%step]
Yes.

[.small-h2]
=== Sanely-automatic derivation

I implemented wrapper around Jsoniter (on Scala 3-only) which works like this:

[source,scala]
--
TODO
--

=== !

How does it compare to Circe or normal Jsoniter Scala?

=== !

image::img/json-compilation-times-4.png[Json Compilation Times,80%,80%]

[.small]
(less is better)

[NOTE.speaker]
--

[source]
----
                     Scala 2   Scala 3  Units
compilation of      cold hot  cold hot
circeGenericAuto      14   4    46  16      s
circeGenericSemi      12   3    10   1      s
circeMagnoliaAuto     13   2    65  32      s
circeMagnoliaSemi     12   7    12   2      s
jsoniterScalaSanely    -   -     9   1      s
jsoniterScalaSemi     10   4     8   1      s
----
--

=== !

Scala 2.13.14

[source,scala]
--
[info] Benchmark                          Mode  Cnt   Score   Error   Units
[info] JsonRoundTrips.circeGenericAuto    thrpt  10   7.319 ± 0.011  ops/ms
[info] JsonRoundTrips.circeGenericSemi    thrpt  10   6.775 ± 0.013  ops/ms
[info] JsonRoundTrips.circeMagnoliaAuto   thrpt  10   7.689 ± 0.013  ops/ms
[info] JsonRoundTrips.circeMagnoliaSemi   thrpt  10   7.838 ± 0.013  ops/ms
[info] JsonRoundTrips.jsoniterScalaSemi   thrpt  10  20.081 ± 0.151  ops/ms
--

Scala 3.3.3

[source,scala]
--
[info] Benchmark                            Mode  Cnt   Score   Error   Units
[info] JsonRoundTrips.circeGenericAuto     thrpt   10   0.490 ± 0.432  ops/ms
[info] JsonRoundTrips.circeGenericSemi     thrpt   10   4.607 ± 0.014  ops/ms
[info] JsonRoundTrips.circeMagnoliaAuto    thrpt   10   0.077 ± 0.039  ops/ms
[info] JsonRoundTrips.circeMagnoliaSemi    thrpt   10   5.590 ± 0.013  ops/ms
[info] JsonRoundTrips.jsoniterScalaSemi    thrpt   10  21.480 ± 0.070  ops/ms
[info] JsonRoundTrips.jsoniterScalaSanely  thrpt   10  21.408 ± 0.070  ops/ms
--

[.small]
(more is better)

=== !

But *Jsoniter parsing `String` s* vs *Circe parsing `Json`* might be apples vs oranges.

Can we have some more *fair* comparison?

== More fair comparison

=== !

[source,scala]
--
trait FastShowPretty[A] {

  def showPretty(
    value:   A,
    sb:      StringBuilder,
    indent:  String = "  ",
    nesting: Int = 0
  ): StringBuilder
}

implicit class FastShowPrettyOps[A](private val value: A) {

  def showPretty(indent: String = "  ", nesting: Int = 0)(
    implicit fsp: FastShowPretty[A]
  ): String =
    fsp.showPretty(value, new StringBuilder, indent, nesting).toString()
}
--

[source,scala]
--
case class Street(name: String)
case class Address(street: Street)
case class User(name: String, address: Address)

println(User("John", Address(Street("Paper St"))).showPretty())
--

[source,scala]
--
User(
  name = "John",
  address = Address(
    street = Street(
      name = "Paper St"
    )
  )
)
--

=== !

[%step]
* automatic and semi-automatic derivation using *Shapeless* (Scala 2)
* automatic and semi-automatic derivation using *Mirror* s (Scala 3)
* automatic and semi-automatic derivation using *Magnolia* (Scala 2 & 3)
* sanely-automatic derivation with macros and *Chimney macro commons* (Scala 2 & 3)

[NOTE.speaker]
--
For startes I implemented sanely-automatic derivation in naive way - inlining everything.
--

=== !

image::img/show-compilation-times-1.png[Show Compilation Times,80%,80%]

[.small]
(less is better)

[NOTE.speaker]
--

[source]
----
                            Scala 2   Scala 3  Units
compilation of             cold hot  cold hot
showGenericProgrammingAuto   15   5    53  29      s
showGenericProgrammingSemi   10   2    10   2      s
showMagnoliaAuto             10   1    43  15      s
showMagnoliaSemi             10   2     9   1      s
showSanely                   14   4    16   5      s
----
--

=== !

Scala 2.13.14

[source,scala]
--
[info] Benchmark                                Mode  Cnt  Score   Error   Units
[info] ShowOutputs.showGenericProgrammingAuto  thrpt   10  2.651 ± 0.012  ops/ms
[info] ShowOutputs.showGenericProgrammingSemi  thrpt   10  2.829 ± 0.033  ops/ms
[info] ShowOutputs.showMagnoliaAuto            thrpt   10  3.621 ± 0.017  ops/ms
[info] ShowOutputs.showMagnoliaSemi            thrpt   10  3.745 ± 0.028  ops/ms
[info] ShowOutputs.showSanely                  thrpt   10  2.202 ± 0.359  ops/ms
--

Scala 3.3.3

[source,scala]
--
[info] Benchmark                                Mode  Cnt  Score   Error   Units
[info] ShowOutputs.showGenericProgrammingAuto  thrpt   10  0.156 ± 0.013  ops/ms
[info] ShowOutputs.showGenericProgrammingSemi  thrpt   10  3.492 ± 0.013  ops/ms
[info] ShowOutputs.showMagnoliaAuto            thrpt   10  0.090 ± 0.023  ops/ms
[info] ShowOutputs.showMagnoliaSemi            thrpt   10  3.918 ± 0.012  ops/ms
[info] ShowOutputs.showSanely                  thrpt   10  2.204 ± 0.396  ops/ms
--

=== !

[%step]
But wait.

[%step]
Jsoniter had one more trick. It "caches" subroutines as `def` s.

[%step]
Would that make a difference?

=== !

image::img/show-compilation-times-2.png[Show Compilation Times,80%,80%]

[.small]
(less is better)

[NOTE.speaker]
--

[source]
----
                            Scala 2   Scala 3  Units
compilation of             cold hot  cold hot
showGenericProgrammingAuto   15   5    53  29      s
showGenericProgrammingSemi   10   2    10   2      s
showMagnoliaAuto             10   1    43  15      s
showMagnoliaSemi             10   2     9   1      s
showSanely                    6   1     7   1      s
----
--

=== !

Scala 2.13.14

[source,scala]
--
[info] Benchmark                                Mode  Cnt  Score   Error   Units
[info] ShowOutputs.showGenericProgrammingAuto  thrpt   10  2.651 ± 0.012  ops/ms
[info] ShowOutputs.showGenericProgrammingSemi  thrpt   10  2.829 ± 0.033  ops/ms
[info] ShowOutputs.showMagnoliaAuto            thrpt   10  3.621 ± 0.017  ops/ms
[info] ShowOutputs.showMagnoliaSemi            thrpt   10  3.745 ± 0.028  ops/ms
[info] ShowOutputs.showSanely                  thrpt   10  4.811 ± 0.026  ops/ms
--

Scala 3.3.3

[source,scala]
--
[info] Benchmark                                Mode  Cnt  Score   Error   Units
[info] ShowOutputs.showGenericProgrammingAuto  thrpt   10  0.156 ± 0.013  ops/ms
[info] ShowOutputs.showGenericProgrammingSemi  thrpt   10  3.492 ± 0.013  ops/ms
[info] ShowOutputs.showMagnoliaAuto            thrpt   10  0.090 ± 0.023  ops/ms
[info] ShowOutputs.showMagnoliaSemi            thrpt   10  3.918 ± 0.012  ops/ms
[info] ShowOutputs.showSanely                  thrpt   10  4.800 ± 0.042  ops/ms
--

[.small]
=== Bonus: debugging

[source,scala]
--
case class Street(name: Either[String, Nothing])
case class Address(street: Street)
case class User(name: String, address: Address)

// scalacOptions += "-Xmacro-settings:fastshowpretty.logging=true"
def printObject(out: User): String = out.showPretty()
--

[source,scala]
--
[info] .../ShowSanely.scala:12:54: Logs:
[info]  - Started derivation for value : example.ShowSanely.User
[info]  - Attempting rule ImplicitRule
[info]  - Skipped summoning example.showmacros.FastShowPretty[example.ShowSanely.User]
[info]  - Attempting rule CachedDefRule
[info]  - Attempting rule BuildInRule
[info]  - Attempting rule ProductRule
[info]  - Checking if def for example.ShowSanely.User exists
[info]  - Started deriving def for example.ShowSanely.User
[info]    - Started derivation for string : java.lang.String
[info]    - Attempting rule ImplicitRule
[info]    - Attempting rule CachedDefRule
[info]    - Attempting rule BuildInRule
[info]    - Successfully shown java.lang.String: sb.append("\"").append(string).append("\"")
[info]    - Started derivation for address : example.ShowSanely.Address
[info]    - Attempting rule ImplicitRule
[info]    - Attempting rule CachedDefRule
[info]    - Attempting rule BuildInRule
[info]    - Attempting rule ProductRule
[info]    - Checking if def for example.ShowSanely.Address exists
[info]    - Started deriving def for example.ShowSanely.Address
[info]      - Started derivation for street : example.ShowSanely.Street
[info]      - Attempting rule ImplicitRule
[info]      - Attempting rule CachedDefRule
[info]      - Attempting rule BuildInRule
[info]      - Attempting rule ProductRule
[info]      - Checking if def for example.ShowSanely.Street exists
[info]      - Started deriving def for example.ShowSanely.Street
[info]        - Started derivation for either : scala.util.Either[java.lang.String, scala.Nothing]
[info]        - Attempting rule ImplicitRule
[info]        - Attempting rule CachedDefRule
[info]        - Attempting rule BuildInRule
[info]        - Attempting rule ProductRule
[info]        - Attempting rule SumTypeRule
[info]        - Checking if def for scala.util.Either[java.lang.String, scala.Nothing] exists
[info]        - Started deriving def for scala.util.Either[java.lang.String, scala.Nothing]
[info]          - Started derivation for left : scala.util.Left[java.lang.String, scala.Nothing]
[info]          - Attempting rule ImplicitRule
[info]          - Attempting rule CachedDefRule
[info]          - Attempting rule BuildInRule
[info]          - Attempting rule ProductRule
[info]          - Checking if def for scala.util.Left[java.lang.String, scala.Nothing] exists
[info]          - Started deriving def for scala.util.Left[java.lang.String, scala.Nothing]
[info]            - Started derivation for string : java.lang.String
[info]            - Attempting rule ImplicitRule
[info]            - Attempting rule CachedDefRule
[info]            - Attempting rule BuildInRule
[info]            - Successfully shown java.lang.String: sb.append("\"").append(string).append("\"")
[info]          - Cached result of def for scala.util.Left[java.lang.String, scala.Nothing]
[info]          - Successfully shown scala.util.Left[java.lang.String, scala.Nothing]: show_nothing$u005D(left, nesting)
[info]          - Started derivation for right : scala.util.Right[java.lang.String, scala.Nothing]
[info]          - Attempting rule ImplicitRule
[info]          - Attempting rule CachedDefRule
[info]          - Attempting rule BuildInRule
[info]          - Attempting rule ProductRule
[info]          - Checking if def for scala.util.Right[java.lang.String, scala.Nothing] exists
[info]          - Started deriving def for scala.util.Right[java.lang.String, scala.Nothing]
[info]            - Started derivation for nothing : scala.Nothing
[info]            - Attempting rule ImplicitRule
[info]            - Attempting rule CachedDefRule
[info]            - Attempting rule BuildInRule
[info]          - Cached result of def for scala.util.Right[java.lang.String, scala.Nothing]
[info]        - Cached result of def for scala.util.Either[java.lang.String, scala.Nothing]
[info]      - Cached result of def for example.ShowSanely.Street
[info]    - Cached result of def for example.ShowSanely.Address
[info]  - Cached result of def for example.ShowSanely.User
[info]   def printObject(out: User): String = out.showPretty()
[info]                                                      ^
--

[source,scala]
--
[error] .../ShowSanely.scala:12:54: Failed to derive showing for value : example.ShowSanely.User:
[error] No build-in support nor implicit for type scala.Nothing
[error]   def printObject(out: User): String = out.showPretty()
[error]                                                      ^
--

== Summary

== Thank you!

image::img/qr-code.png[Link to examples,40%,40%]

https://github.com/MateuszKubuszok/derivation-benchmarks

