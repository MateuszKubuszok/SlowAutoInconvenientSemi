// 35 minutes
:revealjs_totalTime: 2100
:revealjs_theme: serif
:revealjs_help: true

= Slow-Auto, Inconvenient-Semi

**escaping false dichotomy with sanely-automatic derivation**

---

Mateusz Kubuszok

[NOTE.speaker]
--
Most of you probably used some Scala library based on type class derivation.

Most of you probably started with so-called automatic derivation, and at some point it bite you with long compilation times or hard to debuf errors.

Some of you moved to moved to so-called semi-automatic derivation, which is much more clumsy, but tries to solve some of the issues with automatic derivation.

In this presentation, I'll try to show that all of these issues are not some inherit cost of using type class derivation, but that we all did it wrong.
--

== About me

[%step]
* breaking things in Scala for 9 years
* a little bit of open source - including co-authoring Chimney for over 7 years now
* blog at https://kubuszok.com[Kubuszok.com]
* niche https://leanpub.com/jvm-scala-book[Things you need to know about JVM (that matter in Scala)] ebook

[NOTE.speaker]
--
I've been working with Scala for over 9 years,

and 7 of them I've been a maintainer of a library with rather complex metaprogramming.

Additionally, I've been blogging, speaking at meetups and conferences like this one, and also wrote a book about Scala and JVM, so maybe I am not here by accident.

But enough about me. Let's see today's game plan.
--

== Agenda

[%step]
* what is a *type class*
* what is type class *derivation*
* *automatic* and *semi-automatic* derivation a'la Circe
* semi-automatic derivation a'la Jsoniter
* sanely-automatic derivation a'la Chimney
* does it matter to a *library users* how these approach differ

[NOTE.speaker]
--
We'll start with _briefly_ saying what is a type-class, since _some_ of you might not be familiar with the term.

Then we explain what we mean by _type class derivation_, because it has nothing to do with integrals and calculus.

Then we take a look at what people mean by automatic and semi-automatic derivation - in libraries which almost always followed Circe's approach.

Then we show that not all libraries follow this approach, when it comes to semi-automatic derivation.

And some libraries have some improvements also when it comes to automatic derivation.

Hopefully, by the end of this talk, you will understand that how the library's author implement the whole mechanics, impacts you, the users.

But I have to worn you, this is not Shapeless/Mirrors/Magnolia/or macros tutorial.
--

=== Examples

image::img/qr-code.png[Link to examples,40%,40%]

https://github.com/MateuszKubuszok/derivation-benchmarks

[NOTE.speaker]
--
We will be talking how these design choices of library's authors affect you, the users.

If you are curious about the code that generated the numbers or error messages, everything that we compare,
you can take a look at this link, and investigate the code at your own pace.

As an excercise for the reader.

So let's start.
--

== Type class

[%step]
* interface
* with type paremeters
* whose implementation can be automatically provided based on their type only

[NOTE.speaker]
--
Type class, what it is?

As far as I care it is an interface.

But it's an interface with some type parameter.

So that each implementation,that we'd use, could be distinguished only by type, and we could let the compiler pass it around for us.

For example.
--

=== !

[source, scala]
--
trait Encoder[A] {
  def apply(a: A): Json // <-- JSON as data
}
object Encoder {
  given encodeString: Encoder[String] = ...
  given encodeInt: Encoder[Int] = ...
  given encodeDouble: Encoder[Double] = ...
}
--

[%step]
[source, scala]
--
extension [A](value: A) {
  def asJson(using encoder: Encoder[A]): Json = encoder(value)
}
--

[%step]
[source, scala]
--
"value".asJson // using Encoder.encodeString
1024.asJson // using Encoder.encodeInt
3.13.asJson // using Encoder.encodeDouble
--

[NOTE.speaker]
--
We has some data type representing JSONs.

We want to be able to encode our type, whatever it is, to JSON.

For starters, we have implementation for the primitives.

And some extension methods, so that the code would look nice.

Then with the mechanism called `implicit`s or, on Scala 3, `using` and `given`, these implementations can be passed for us automatically.

However, we only provided some implementations. (next slide)
--

=== !

What if nobody wrote the implementation explicitly for *my type*?

[%step]
[source, scala]
--
case class Address(value: String)
case class User(name: String, address: Address)
--

[%step]
[source, scala]
--
Address("Paper St. 19").asJson // ???
User("John Smith", Address("Paper St. 19")).asJson // ???
--

[%step]
[source]
--
No given instance of type Encoder[Address] was found for parameter encoder of
method asJson in object ...
No given instance of type Encoder[User] was found for parameter encoder of
method asJson in object ...
--

[NOTE.speaker]
--
What if nobody wrote the implementation explicitly for *my type*?

We can have, some `Address` and some `User` defined.

What is going to happen when we try to encode them?

The answer is that the compilation would fail. Because there are no implementations for these types.

That's where the derivation comes in.
--

== Type class derivation

image::img/derivation.png[Derivation,100%,100%]

[.small]
(If you don't understand this diagram, you probably haven't spend 600h on a topic that most sane people avoid. The main reason we have these images is because people like colorful images on slides.)

[NOTE.speaker]
--
Type class derivation.

We'll have several of these pictures, which you can study at your own pace at home.

For now what I want you to remember:

 * derivation is about picking the implementations for some parts of your type, and combining them together into the implementation for the whole type
 * for `case class`es, it means that you have to have an implementation for each field's type
 * for `sealed traits and `enum`s, it means that you have to have implementation for each subtype
 * because it combines the implementations from bottom-up someone, usually, the library's author have to provide implementations for the smallest blocks, usualy primitives
 * and, because there is no magic, someone has to define how these small blocks can be combined, usually that's also the author of the library
 * and if that sounds confusing, it only because you haven't spend way too much time on this subject

Maybe some example would help.
--

=== Derivation a'la Circe

=== !

[source, scala]
--
trait Encoder[A] {
  def apply(a: A): Json // <-- JSON as data
}
--

[%step]
[source, scala]
--
extension [A](value: A) {
  def asJson(using encoder: Encoder[A]): Json = encoder(value)
}
--

[%step]
[source, scala]
--
case class Address(value: String)
case class User(name: String, address: Address)
--

[%step]
[source, scala]
--
Address("Paper St. 19")
// { "value": "Paper St. 19" }
User("John Smith", Address("Paper St. 19"))
// { "name": "John Smith", "address": { "value": "Paper St. 19" } }
--

[%step]
[source, scala]
--
import MagicImportOfSomethingThatCreatesEncoders.given

Address("Paper St. 19").asJson // generates Encoder[Address] on demand
User("John Smith", Address("Paper St. 19")).asJson // ditto but for User
--

[%step]
[source, scala]
--
import ImportOfSomethingThatLetsYouCreateEncoders.deriveEncoder

given addressEncoder: Encoder[Address] = deriveEncoder[Address]
given userEncoder: Encoder[User] = deriveEncoder[User]

Address("Paper St. 19").asJson // using addressEncoder
User("John Smith", Address("Paper St. 19")).asJson // using userEncoder
--

[NOTE.speaker]
--
As a reminder, we have this `Encoder`, which should turn your `case class` into JSON.

It has this nice extension method.

And we want to encode these `case class`es.

The library's author has some assumption, like for instance, that each `case class` should be encoded as JSON object. Each field's name would turn into that object's key, and value, should be encoded, with the encoder for its type.

Automatic derivation assumes that all the missing implementations, that you have not provided yourself have an automatic fallback, often enabled with an import. You add that import, fallback becomes available in the implicit scope, and everything works. (Sometimes, this is implemented in the compation objects and then it cannot be disabled).

Semi-automatic derivation assumes that you want to define these implicits yourself, but you don't want to write their implementation. It gives you some method, which would give you a new implementation, and even if there is implicit of a demanded type in scope, it ignores it. (So that you won't end up with cyclical dependeny in the initialization).

If you will not write thise implicits/givens yourself, you'll keep on getting implicit not found.

But let's take a look a bit closer.
--

[.small-h2]
=== Automatic derivation of Address

[source, scala]
--
implicitly[Encoder[Address]] // <-- using Encoder[Address]
--

image::img/automatic-derivation-of-Address.png[Automatic Derivation of Address,100%,100%]

[NOTE.speaker]
--
What happens when we try to summon an instance with automatic derivation? Using `Address` as an example.

(Reminder: this and the following diagrams are also something you can study at your own pace at home.)

First of all, automatic derivation should be a fallback, so the compiler tries to find some existing implementation and failed.

Then, it sees that we have a `case class`, and we just happen to have some mechanism implemented by authors which would

 * obtain the implementation for each field
 * combine them together

Now, the semi-automatic.
--

[.small-h2]
=== Semi-automatic derivation of Address

[source, scala]
--
deriveEncoder[Address] // <-- creates new Encoder[Address]
--

image::img/semi-automatic-derivation-of-Address.png[Semi-automatic Derivation of Address,100%,100%]

[NOTE.speaker]
--
Here, we can see that there is no, try-existing-then-use-fallback part. We moved directly into creating new instance.

If it cannot be created, the compilation fails, even if such instance exist and is in scope.

Is there any difference when you try these approach with `User`.
--

[.small-h2]
=== Automatic derivation of User

[source, scala]
--
implicitly[Encoder[User]] // <-- using Encoder[User]
--

image::img/automatic-derivation-of-User.png[Automatic Derivation of User,100%,100%]

[NOTE.speaker]
--
Well, there is, the diagram is much bigger. Why?

Because, with automatic derivation in scope the compiler automatically, as a fallback, not only the implementation for the type we asked for, but also implementations for the types nested in this type.

Here, it triggers the automatic derivation of `Address`.

Is it try for semi-automatic derivation as well?
--

[.small-h2]
=== Semi-automatic derivation of User

[source, scala]
--
deriveEncoder[User] // <-- creates new Encoder[User]
--

image::img/semi-automatic-derivation-of-User.png[Semi-automatic Derivation of User,100%,100%]

[NOTE.speaker]
--
No. If we haven't imported automatic derivation next to semi-automatic, if we didn't create that implicit `Encoder` of `Address`, the compilation would fail.

Semi-automatic derivation in Circe, and libraries based on its approach, are not recursive.

In case you look at all of this, and as yourself... _(next slide)_
--

== OK, but where is the code?

Wouldn't it be easier to understand with some examples?

[NOTE.speaker]
--
...where is the code?

Reminder: _(next slide)_
--

=== 1. We are focusing on user-side of the derivation story

[NOTE.speaker]
--
One. Our goal is it see how something that we didn't wrote but someone else affect us.
--

=== 2. Code is in the link

image::img/qr-code.png[Link to examples,40%,40%]

https://github.com/MateuszKubuszok/derivation-benchmarks

[NOTE.speaker]
--
Two. You can look at the code whenever you want.
--

[.small-h2.columns]
=== 3. If you really need the derivation-internals-explanation-experience

[%step]
[.column]
image::img/3-hours-later.jpg[3h later,80%,80%]

[%step]
[.column]
image::img/everyday-we-stray-further-from-god.png[3h later,80%,80%]

[NOTE.speaker]
--
If we actually try to show it, and explain it during this presentation.

It would take half the conference.

The whole audience would be traumatised, and we would still not get to the point I'm trying to make.

So, getting back to the main topic.
--

== Why people bother with semi-automatic derivation?

=== 1. They want to make sure that they use the same implementation everywhere

[NOTE.speaker]
--
We're not going to question that use case. If you want to have the same implementation everywhere, you define it only once and reuse.
--

=== 2. "Speed"

[NOTE.speaker]
--
But the other reason people have strong preference for semi is speed.

There were a lot of horror stories about a single implicit compiling for several minutes. (I saw some myself).

A lot of people did investigation - compiler benchmarks, flame graphs, time spend in different compilation phases - and found that the cause is automatic derivation.

Semi-automatic derivation solved their problems.

But is it still true today?
--

=== !

[source, scala]
--
// We're use Circe:
// trait Encoder[A] { ... } turns A -> Json
// trait Decoder[A] { ... } turns Json -> Either[Decoder.DecodingError, A]

case class Out(...) // <-- really big case class with nested case classes

// value -> Json -> value again
def roundTrip(out: Out): (Json, Either[Decoder.DecodingError, Out]) = {
  val json = out.asJson // <-- encode as Json using Encoder[Out]
  val parsed = json.as[Out] // <-- decode from Json using  Decoder[Out]
  json -> parsed
}
--

[%step]
[source,scala]
--
// Semi-automatic version will just have this:
implicit val in1Decoder: Decoder[In1] = deriveDecoder
implicit val in1Encoder: Encoder[In1] = deriveEncoder
implicit val in2Decoder: Decoder[In2] = deriveDecoder
implicit val in2Encoder: Encoder[In2] = deriveEncoder
implicit val in3Decoder: Decoder[In3] = deriveDecoder
implicit val in3Encoder: Encoder[In3] = deriveEncoder
implicit val in4Decoder: Decoder[In4] = deriveDecoder
implicit val in4Encoder: Encoder[In4] = deriveEncoder
implicit val in5Decoder: Decoder[In5] = deriveDecoder
implicit val in5Encoder: Encoder[In5] = deriveEncoder
implicit val outDecoder: Decoder[Out] = deriveDecoder
implicit val outEncoder: Encoder[Out] = deriveEncoder
// instead of automatic derivation import.
--

This shouldn't be hard?

[NOTE.speaker]
--
I defined some very mean nested case class. All you need to know that it's 5 levels of nesting deep.

I want to use Circe, both Encoder and Decoder, and do a round trip - encode this case class, and then decode it, for example to test if I get the same value or do some benchmarks.

I try to do it once with automatic derivation, and once with semi-automatic approach.

Both will be single-file modules which only generate a few codecs. How bad it can be? 
--

=== !

image::img/json-compilation-times-1.png[Json Compilation Times,80%,80%]

[.small]
(less is better)

[NOTE.speaker]
--
On Scala 2.13, not so bad. The compilation times are quite close, not deserving the bad press.

Of course, if we ignore the fact that both need at least 12 seconds on cold JVM to compile a single short file.

But on Scala 3 with automatic we have 46 seconds to compile a single file on cold JVM! On the other hand semi-auto works much faster!

What about runtime?

[source]
----
                     Scala 2   Scala 3  Units
compilation of      cold hot  cold hot
circeGenericAuto      14   4    46  16      s
circeGenericSemi      12   3    10   1      s
circeMagnoliaAuto     13   2    65  32      s
circeMagnoliaSemi     12   7    12   2      s
jsoniterScalaSanely    -   -     9   1      s
jsoniterScalaSemi     10   4     8   1      s
----
--

=== !

Scala 2.13.14

[source,scala]
--
[info] Benchmark                          Mode  Cnt   Score   Error   Units
[info] JsonRoundTrips.circeGenericAuto    thrpt  10   7.319 ± 0.011  ops/ms
[info] JsonRoundTrips.circeGenericSemi    thrpt  10   6.775 ± 0.013  ops/ms
--

Scala 3.3.3

[source,scala]
--
[info] Benchmark                            Mode  Cnt   Score   Error   Units
[info] JsonRoundTrips.circeGenericAuto     thrpt   10   0.490 ± 0.432  ops/ms
[info] JsonRoundTrips.circeGenericSemi     thrpt   10   4.607 ± 0.014  ops/ms
--

[.small]
(more is better)

[NOTE.speaker]
--
Scala 2.13 has very small differences between auto and semi in benchmarks as well.

Scala 3 on the other hand... semi-automatic derivation 1/3rd slower than Scala 2.13!

But the automatic derivation is a disaster - an order of magnitude slower than that.

Can we example these results?
--

[.small-h2]
=== Auto vs Semi on Scala 2

[.small]
[%step]
* https://github.com/scala/scala/pull/5649[PR #5649] - _Faster compilation of inductive implicits_ (closed)
* https://github.com/scala/scala/pull/6481[PR #6481] - _Topic/inductive implicits 2.13.x_ (closed)
* https://github.com/scala/scala/pull/6580[PR #6580] - _Prune polymorphic implicits more aggressively_ (merged)
* https://github.com/scala/scala/pull/7012[PR #7012] - _Speed up implicit resolution by avoiding allocations when traversing TypeRefs in core_ (merged)
* and more

[.small]
[%step]
[source, scala]
--
             1) baseline - scalac 2.13.x  2) scalac 2.13.x with matchesPtInst
 HList Size
  50          4                            3
 100          7                            3
 150         15                            4
 200         28                            4
 250         48                            5
 300         81                            6
 350        126                            8
 400        189                           11
 450        322                           13
 500        405                           16         Compile time in seconds
--

[NOTE.speaker]
--
Autor of Shapeless spend a lot of time contributing to the compiler, to optimize the implici resolution. He made a whole series of PRs.

2 of them got closed, but the 3rd one finally got merged and released as a part of 2.13.0-M5.

And then there was another one.

We can see that he was pretty happy with the result because we boasted how the compilation times went down.

Some of that work was ported to Scala 3 but perhaps not everything, or maybe these opimization do not play well with how Mirrors work.

And all the bad press that automatic derivation has comes probably from before these PRs. Or maybe people were deriving exactly the same implicit 50 times.

Putting these optimizations aside _(next slide)_
--

=== !

Could something else improve performance?

[NOTE.speaker]
--
Before Scala 3, some people believed that yes. For instance replacing Shapeless.
--

== Magnolia

[%step]
* alternative to Shapeless/Mirrors
* boasts about:

   - better API
   - better performance
   - better compilation times
   - better error messages when derivation fail

[.small]
=== Error messages

Semi-automatic derivation

[source,scala]
--
case class Street(name: Either[String, Nothing]) // <-- should not be able to derive name
case class Address(street: Street)
case class User(name: String, address: Address)
--

[source,scala]
--
implicit val streetEncoder: Encoder[Street] = deriveEncoder
implicit val addressEncoder: Encoder[Address] = deriveEncoder
implicit val userEncoder: Encoder[User] = deriveEncoder

user.asJson
--

Shapeless' errors

[source,scala]
--
could not find Lazy implicit value of type DerivedAsObjectEncoder[Street]
   implicit val streetEncoder: Encoder[Street] = deriveEncoder
                                                 ^
--

Mirrors' errors

[source,scala]
--
  implicit val streetEncoder: Encoder[Street] = deriveEncoder
                                                ^^^^^^^^^^^^^
Failed to find an instance of Encoder[Either[String, Nothing]]
--

Magnolia's errors

[source,scala]
--
magnolia: could not find Encoder.Typeclass for type Either[String,Nothing]
     in parameter 'name' of product type Street
   implicit val streetEncoder: Encoder[Street] = EncoderSemi.derived
                                                             ^
--

[NOTE.speaker]
--
We implemented out own simplified Circe-Magnolia on Scala 2 and 3.
--

=== !

Automatic derivation

[source,scala]
--
case class Street(name: Either[String, Nothing])
case class Address(street: Street)
case class User(name: String, address: Address)

user.asJson
--

Shapeless/Mirrors/Magnolia

[source,scala]
--
could not find implicit value for parameter encoder: Encoder[User]
     user.asJson
          ^
--

=== !

image::img/json-compilation-times-2.png[Json Compilation Times,80%,80%]

[.small]
(less is better)

[NOTE.speaker]
--
Probably the common knowledge about Magnolia's compile times on Scala 2 is outdated on Scala 3.

[source]
----
                     Scala 2   Scala 3  Units
compilation of      cold hot  cold hot
circeGenericAuto      14   4    46  16      s
circeGenericSemi      12   3    10   1      s
circeMagnoliaAuto     13   2    65  32      s
circeMagnoliaSemi     12   7    12   2      s
jsoniterScalaSanely    -   -     9   1      s
jsoniterScalaSemi     10   4     8   1      s
----
--

=== !

Scala 2.13.14

[source,scala]
--
[info] Benchmark                          Mode  Cnt   Score   Error   Units
[info] JsonRoundTrips.circeGenericAuto    thrpt  10   7.319 ± 0.011  ops/ms
[info] JsonRoundTrips.circeGenericSemi    thrpt  10   6.775 ± 0.013  ops/ms
[info] JsonRoundTrips.circeMagnoliaAuto   thrpt  10   7.689 ± 0.013  ops/ms
[info] JsonRoundTrips.circeMagnoliaSemi   thrpt  10   7.838 ± 0.013  ops/ms
--

Scala 3.3.3

[source,scala]
--
[info] Benchmark                            Mode  Cnt   Score   Error   Units
[info] JsonRoundTrips.circeGenericAuto     thrpt   10   0.490 ± 0.432  ops/ms
[info] JsonRoundTrips.circeGenericSemi     thrpt   10   4.607 ± 0.014  ops/ms
[info] JsonRoundTrips.circeMagnoliaAuto    thrpt   10   0.077 ± 0.039  ops/ms
[info] JsonRoundTrips.circeMagnoliaSemi    thrpt   10   5.590 ± 0.013  ops/ms
--

[.small]
(more is better)

[NOTE.speaker]
--
Magnolia on Scala 3 was implemented on top of Mirrors.
--

=== !

Shapeless/Mirrors/Magnolia - different APIs, same approach.

Did anyone try something else?

== Jsoniter Scala

[%step]
* prioritizes *performance*
* *no automatic* derivation
* *no need* to derive *intermediate* instances

[%step]
How?

=== !

[source,scala]
--
// Yes, only 1 codec, no need to manually derive implicits for nested cases
implicit val outCodec: JsonValueCodec[Out] =
  JsonCodecMaker.make(CodecMakerConfig.withAllowRecursiveTypes(true))

def roundTrip(out: Out): (String, Either[Throwable, Out]) = {
  val str = writeToString(out)
  val parsed = scala.util.Try(readFromString(str)).toEither
  str -> parsed
}
--

[.small-h2]
=== Recursive semi-automatic derivation

image::img/recursive-macro-derivation.png[Recursive Macro Derivation]

[.small-h2.columns]
=== Recursive semi-automatic derivation

[.column]
--
image::img/derivation.png[Derivation]

[.small]
* delegates everything to implicit search
* types supported OOTB are handled via implicits in companion object
--

[.column]
--
image::img/recursive-macro-derivation.png[Recursive Macro Derivation]

[.small]
* use implicit search only for overrides
* types supported OOTB are handled by macro, implicit scope is empty by default
--

=== !

OK, but what does this gibberish mean for users?

=== !

image::img/json-compilation-times-3.png[Json Compilation Times,80%,80%]

[.small]
(less is better)

[NOTE.speaker]
--

[source]
----
                     Scala 2   Scala 3  Units
compilation of      cold hot  cold hot
circeGenericAuto      14   4    46  16      s
circeGenericSemi      12   3    10   1      s
circeMagnoliaAuto     13   2    65  32      s
circeMagnoliaSemi     12   7    12   2      s
jsoniterScalaSanely    -   -     9   1      s
jsoniterScalaSemi     10   4     8   1      s
----
--

=== !

Scala 2.13.14

[source,scala]
--
[info] Benchmark                          Mode  Cnt   Score   Error   Units
[info] JsonRoundTrips.circeGenericAuto    thrpt  10   7.319 ± 0.011  ops/ms
[info] JsonRoundTrips.circeGenericSemi    thrpt  10   6.775 ± 0.013  ops/ms
[info] JsonRoundTrips.circeMagnoliaAuto   thrpt  10   7.689 ± 0.013  ops/ms
[info] JsonRoundTrips.circeMagnoliaSemi   thrpt  10   7.838 ± 0.013  ops/ms
[info] JsonRoundTrips.jsoniterScalaSemi   thrpt  10  20.081 ± 0.151  ops/ms
--

Scala 3.3.3

[source,scala]
--
[info] Benchmark                            Mode  Cnt   Score   Error   Units
[info] JsonRoundTrips.circeGenericAuto     thrpt   10   0.490 ± 0.432  ops/ms
[info] JsonRoundTrips.circeGenericSemi     thrpt   10   4.607 ± 0.014  ops/ms
[info] JsonRoundTrips.circeMagnoliaAuto    thrpt   10   0.077 ± 0.039  ops/ms
[info] JsonRoundTrips.circeMagnoliaSemi    thrpt   10   5.590 ± 0.013  ops/ms
[info] JsonRoundTrips.jsoniterScalaSemi    thrpt   10  21.480 ± 0.070  ops/ms
--

[.small]
(more is better)

[NOTE.speaker]
--
I have to admit: I am cheating, Jsoniter parses and writes to String while, Circe parses and writes to Json AST.
--

=== !

But can it be automatic?

[.small]
== Automatic derivation a'la Chimney

[%step]
Similar problem:

[%step]
* derivation should be recursive
* macro should only use implicits for overrides

[%step]
But:

[%step]
* automatic derivation should be available without breaking the 2 above

[.small-h2]
=== Solution

[%step]
[source,scala]
--
trait TypeClass[A] extends TypeClass.AutoDerived[A] { ... }
object TypeClass {

  // semi-automatic derivation of TypeClass[A]
  inline def derived[A]: TypeClass[A] = ${ derivedImpl[A] }

  trait AutoDerived[A] { ... }
  object AutoDerived extends AutoDerivedLowPriorityImplicits
  trait AutoDerivedLowPriorityImplicits {

    // automatic derivation of TypeClass.AutoDerived[A]
    inline given derived[A]: AutoDerived[A] = ${ derivedImpl[A] }
  }
}
--

[%step]
[source,scala]
--
extension [A](value: A)
  // uses TypeClass[A] defined by user manually or with TypeClass.derived,
  // falling back on automatic derivation
  def method(using TypeClass.AutoDerived[A]) = ...
--

[%step]
[source,scala]
--
// allowed to try summoning TypeClass[Sth].
// NOT allowed to try summoning TypeClass.AutoDerived[Sth]!
def derivedImpl[A: Type]: Expr[TypeClass[A]] = ...
--

[%step]
[.small]
(Disclaimer: understanding this code is *not* necessary to understand its implications on the next slides)

[%step]
[.small]
(Solutions for https://www.scala-lang.org/2024/08/19/given-priority-change-3.7.html[_New Prioritization of Givens in Scala 3.7_] available at the checkout)

[NOTE.speaker]
--
In case I forgot: `summonFrom` for ordering the summons the old way + `opaque type` for the result of such ordered summoning.
--

=== !

Can we test it outside Chimney?

[%step]
Yes.

[.small-h2]
=== Sanely-automatic derivation

I implemented wrapper around Jsoniter (on Scala 3-only) which works like this:

[source,scala]
--
import jsonitersanely.* // <-- 1 import, like with std automatic derivation

def roundTrip(out: Out): (String, Either[Throwable, Out]) = {
  val str = write(out)
  val parsed = scala.util.Try(read[Out](str)).toEither
  str -> parsed
}
--

=== !

How does it compare to Circe or normal Jsoniter Scala?

=== !

image::img/json-compilation-times-4.png[Json Compilation Times,80%,80%]

[.small]
(less is better)

[NOTE.speaker]
--

[source]
----
                     Scala 2   Scala 3  Units
compilation of      cold hot  cold hot
circeGenericAuto      14   4    46  16      s
circeGenericSemi      12   3    10   1      s
circeMagnoliaAuto     13   2    65  32      s
circeMagnoliaSemi     12   7    12   2      s
jsoniterScalaSanely    -   -     9   1      s
jsoniterScalaSemi     10   4     8   1      s
----
--

=== !

Scala 2.13.14

[source,scala]
--
[info] Benchmark                          Mode  Cnt   Score   Error   Units
[info] JsonRoundTrips.circeGenericAuto    thrpt  10   7.319 ± 0.011  ops/ms
[info] JsonRoundTrips.circeGenericSemi    thrpt  10   6.775 ± 0.013  ops/ms
[info] JsonRoundTrips.circeMagnoliaAuto   thrpt  10   7.689 ± 0.013  ops/ms
[info] JsonRoundTrips.circeMagnoliaSemi   thrpt  10   7.838 ± 0.013  ops/ms
[info] JsonRoundTrips.jsoniterScalaSemi   thrpt  10  20.081 ± 0.151  ops/ms
--

Scala 3.3.3

[source,scala]
--
[info] Benchmark                            Mode  Cnt   Score   Error   Units
[info] JsonRoundTrips.circeGenericAuto     thrpt   10   0.490 ± 0.432  ops/ms
[info] JsonRoundTrips.circeGenericSemi     thrpt   10   4.607 ± 0.014  ops/ms
[info] JsonRoundTrips.circeMagnoliaAuto    thrpt   10   0.077 ± 0.039  ops/ms
[info] JsonRoundTrips.circeMagnoliaSemi    thrpt   10   5.590 ± 0.013  ops/ms
[info] JsonRoundTrips.jsoniterScalaSemi    thrpt   10  21.480 ± 0.070  ops/ms
[info] JsonRoundTrips.jsoniterScalaSanely  thrpt   10  21.408 ± 0.070  ops/ms
--

[.small]
(more is better)

=== !

But *Jsoniter parsing `String` s* vs *Circe parsing `Json`* might be apples vs oranges.

Can we have some more *fair* comparison?

== More fair comparison

=== !

[source,scala]
--
trait FastShowPretty[A] {

  def showPretty(
    value:   A,
    sb:      StringBuilder,
    indent:  String = "  ",
    nesting: Int = 0
  ): StringBuilder
}

implicit class FastShowPrettyOps[A](private val value: A) {

  def showPretty(indent: String = "  ", nesting: Int = 0)(
    implicit fsp: FastShowPretty[A]
  ): String =
    fsp.showPretty(value, new StringBuilder, indent, nesting).toString()
}
--

[source,scala]
--
case class Street(name: String)
case class Address(street: Street)
case class User(name: String, address: Address)

println(User("John", Address(Street("Paper St"))).showPretty())
--

[source,scala]
--
User(
  name = "John",
  address = Address(
    street = Street(
      name = "Paper St"
    )
  )
)
--

=== !

[%step]
* automatic and semi-automatic derivation using *Shapeless* (Scala 2)
* automatic and semi-automatic derivation using *Mirror* s (Scala 3)
* automatic and semi-automatic derivation using *Magnolia* (Scala 2 & 3)
* sanely-automatic derivation with macros and *Chimney macro commons* (Scala 2 & 3)

[NOTE.speaker]
--
For startes I implemented sanely-automatic derivation in naive way - inlining everything.
--

=== !

image::img/show-compilation-times-1.png[Show Compilation Times,80%,80%]

[.small]
(less is better)

[NOTE.speaker]
--

[source]
----
                            Scala 2   Scala 3  Units
compilation of             cold hot  cold hot
showGenericProgrammingAuto   15   5    53  29      s
showGenericProgrammingSemi   10   2    10   2      s
showMagnoliaAuto             10   1    43  15      s
showMagnoliaSemi             10   2     9   1      s
showSanely                   14   4    16   5      s
----
--

=== !

Scala 2.13.14

[source,scala]
--
[info] Benchmark                                Mode  Cnt  Score   Error   Units
[info] ShowOutputs.showGenericProgrammingAuto  thrpt   10  2.651 ± 0.012  ops/ms
[info] ShowOutputs.showGenericProgrammingSemi  thrpt   10  2.829 ± 0.033  ops/ms
[info] ShowOutputs.showMagnoliaAuto            thrpt   10  3.621 ± 0.017  ops/ms
[info] ShowOutputs.showMagnoliaSemi            thrpt   10  3.745 ± 0.028  ops/ms
[info] ShowOutputs.showSanely                  thrpt   10  2.202 ± 0.359  ops/ms
--

Scala 3.3.3

[source,scala]
--
[info] Benchmark                                Mode  Cnt  Score   Error   Units
[info] ShowOutputs.showGenericProgrammingAuto  thrpt   10  0.156 ± 0.013  ops/ms
[info] ShowOutputs.showGenericProgrammingSemi  thrpt   10  3.492 ± 0.013  ops/ms
[info] ShowOutputs.showMagnoliaAuto            thrpt   10  0.090 ± 0.023  ops/ms
[info] ShowOutputs.showMagnoliaSemi            thrpt   10  3.918 ± 0.012  ops/ms
[info] ShowOutputs.showSanely                  thrpt   10  2.204 ± 0.396  ops/ms
--

=== !

[%step]
But wait.

[%step]
Jsoniter had one more trick. It "caches" subroutines as `def` s.

[%step]
Would that make a difference?

=== !

image::img/show-compilation-times-2.png[Show Compilation Times,80%,80%]

[.small]
(less is better)

[NOTE.speaker]
--

[source]
----
                            Scala 2   Scala 3  Units
compilation of             cold hot  cold hot
showGenericProgrammingAuto   15   5    53  29      s
showGenericProgrammingSemi   10   2    10   2      s
showMagnoliaAuto             10   1    43  15      s
showMagnoliaSemi             10   2     9   1      s
showSanely                    6   1     7   1      s
----
--

=== !

Scala 2.13.14

[source,scala]
--
[info] Benchmark                                Mode  Cnt  Score   Error   Units
[info] ShowOutputs.showGenericProgrammingAuto  thrpt   10  2.651 ± 0.012  ops/ms
[info] ShowOutputs.showGenericProgrammingSemi  thrpt   10  2.829 ± 0.033  ops/ms
[info] ShowOutputs.showMagnoliaAuto            thrpt   10  3.621 ± 0.017  ops/ms
[info] ShowOutputs.showMagnoliaSemi            thrpt   10  3.745 ± 0.028  ops/ms
[info] ShowOutputs.showSanely                  thrpt   10  4.811 ± 0.026  ops/ms
--

Scala 3.3.3

[source,scala]
--
[info] Benchmark                                Mode  Cnt  Score   Error   Units
[info] ShowOutputs.showGenericProgrammingAuto  thrpt   10  0.156 ± 0.013  ops/ms
[info] ShowOutputs.showGenericProgrammingSemi  thrpt   10  3.492 ± 0.013  ops/ms
[info] ShowOutputs.showMagnoliaAuto            thrpt   10  0.090 ± 0.023  ops/ms
[info] ShowOutputs.showMagnoliaSemi            thrpt   10  3.918 ± 0.012  ops/ms
[info] ShowOutputs.showSanely                  thrpt   10  4.800 ± 0.042  ops/ms
--

[.small]
=== Bonus: debugging

[source,scala]
--
case class Street(name: Either[String, Nothing]) // <-- this should fail the derivation
case class Address(street: Street)
case class User(name: String, address: Address)

// scalacOptions += "-Xmacro-settings:fastshowpretty.logging=true"
def printObject(out: User): String = out.showPretty()
--


[source,scala]
--
[error] .../ShowSanely.scala:12:54: Failed to derive showing for value : example.ShowSanely.User:
[error] No build-in support nor implicit for type scala.Nothing
[error]   def printObject(out: User): String = out.showPretty()
[error]                                                      ^
--

[%step]
[source,scala]
--
[info] .../ShowSanely.scala:12:54: Logs:
[info]  - Started derivation for value : example.ShowSanely.User
[info]  - Attempting rule ImplicitRule
[info]  - Skipped summoning example.showmacros.FastShowPretty[example.ShowSanely.User]
[info]  - Attempting rule CachedDefRule
[info]  - Attempting rule BuildInRule
[info]  - Attempting rule ProductRule
[info]  - Checking if def for example.ShowSanely.User exists
[info]  - Started deriving def for example.ShowSanely.User
[info]    - Started derivation for string : java.lang.String
[info]    - Attempting rule ImplicitRule
[info]    - Attempting rule CachedDefRule
[info]    - Attempting rule BuildInRule
[info]    - Successfully shown java.lang.String: sb.append("\"").append(string).append("\"")
[info]    - Started derivation for address : example.ShowSanely.Address
[info]    - Attempting rule ImplicitRule
[info]    - Attempting rule CachedDefRule
[info]    - Attempting rule BuildInRule
[info]    - Attempting rule ProductRule
[info]    - Checking if def for example.ShowSanely.Address exists
[info]    - Started deriving def for example.ShowSanely.Address
[info]      - Started derivation for street : example.ShowSanely.Street
[info]      - Attempting rule ImplicitRule
[info]      - Attempting rule CachedDefRule
[info]      - Attempting rule BuildInRule
[info]      - Attempting rule ProductRule
[info]      - Checking if def for example.ShowSanely.Street exists
[info]      - Started deriving def for example.ShowSanely.Street
[info]        - Started derivation for either : scala.util.Either[java.lang.String, scala.Nothing]
[info]        - Attempting rule ImplicitRule
[info]        - Attempting rule CachedDefRule
[info]        - Attempting rule BuildInRule
[info]        - Attempting rule ProductRule
[info]        - Attempting rule SumTypeRule
[info]        - Checking if def for scala.util.Either[java.lang.String, scala.Nothing] exists
[info]        - Started deriving def for scala.util.Either[java.lang.String, scala.Nothing]
[info]          - Started derivation for left : scala.util.Left[java.lang.String, scala.Nothing]
[info]          - Attempting rule ImplicitRule
[info]          - Attempting rule CachedDefRule
[info]          - Attempting rule BuildInRule
[info]          - Attempting rule ProductRule
[info]          - Checking if def for scala.util.Left[java.lang.String, scala.Nothing] exists
[info]          - Started deriving def for scala.util.Left[java.lang.String, scala.Nothing]
[info]            - Started derivation for string : java.lang.String
[info]            - Attempting rule ImplicitRule
[info]            - Attempting rule CachedDefRule
[info]            - Attempting rule BuildInRule
[info]            - Successfully shown java.lang.String: sb.append("\"").append(string).append("\"")
[info]          - Cached result of def for scala.util.Left[java.lang.String, scala.Nothing]
[info]          - Successfully shown scala.util.Left[java.lang.String, scala.Nothing]: show_nothing$u005D(left, nesting)
[info]          - Started derivation for right : scala.util.Right[java.lang.String, scala.Nothing]
[info]          - Attempting rule ImplicitRule
[info]          - Attempting rule CachedDefRule
[info]          - Attempting rule BuildInRule
[info]          - Attempting rule ProductRule
[info]          - Checking if def for scala.util.Right[java.lang.String, scala.Nothing] exists
[info]          - Started deriving def for scala.util.Right[java.lang.String, scala.Nothing]
[info]            - Started derivation for nothing : scala.Nothing
[info]            - Attempting rule ImplicitRule
[info]            - Attempting rule CachedDefRule
[info]            - Attempting rule BuildInRule
[info]          - Cached result of def for scala.util.Right[java.lang.String, scala.Nothing]
[info]        - Cached result of def for scala.util.Either[java.lang.String, scala.Nothing]
[info]      - Cached result of def for example.ShowSanely.Street
[info]    - Cached result of def for example.ShowSanely.Address
[info]  - Cached result of def for example.ShowSanely.User
[info]   def printObject(out: User): String = out.showPretty()
[info]                                                      ^
--

== Summary

== Thank you!

image::img/qr-code.png[Link to examples,40%,40%]

https://github.com/MateuszKubuszok/derivation-benchmarks

